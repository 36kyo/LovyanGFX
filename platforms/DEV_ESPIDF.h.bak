#ifndef _DEV_ESPIDF_H_
#define _DEV_ESPIDF_H_

// #pragma GCC optimize ("O3")

#include <driver/rtc_io.h>
#include <driver/spi_master.h>
#include <soc/spi_reg.h>
#include <esp32-hal-spi.h>
#include "esp32_common.h"

/*
#define SPI_WAIT \
  while (READ_PERI_REG(SPI_CMD_REG(_SPIPORT))&SPI_USR);

#define SPI_32(H,L) ( ((H)<<8 | (H)>>8) | (((L)<<8 | (L)>>8)<<16 ) )
#define COL_32(H,L) ( ((H)<<8 | (H)>>8) | (((L)<<8 | (L)>>8)<<16 ) )
#define COL_16(C)    ( (C)<<8 | (C)>>8)
*/

//template <typename LCD, uint8_t _SPIPORT, int CS_PIN, int DC_PIN, int FREQ, int FREQ_FILL = -1, int FREQ_READ = -1>
//template <typename LCD, LovyGFX_Config* GFX_CONFIG, int CS_PIN, int DC_PIN, int FREQ, int FREQ_FILL = -1, int FREQ_READ = -1>
template <typename LCD, spi_host_device_t _spi_host, int CS_PIN, int DC_PIN, int FREQ, int FREQ_FILL = -1, int FREQ_READ = -1>
class DEV_ESPIDF
{
  static void lcd_spi_pre_transfer_callback(spi_transaction_t *t)
  {
    gpio_set_level((gpio_num_t)DC_PIN, !(uint32_t)t->user);
  }

  static void lcd_spi_post_transfer_callback(spi_transaction_t *t)
  {
  }

  uint8_t _rotation, _colstart, _rowstart;
  int16_t _width, _height;
  uint32_t _caset, _paset;

  //const uint8_t _SPIPORT = _spi.bus()->num;
  spi_dev_t *_spi_dev; // = spicommon_hw_for_host(_spi_host);
  //spi_device_handle_t _spi_handle;

  inline void tft_Write_8(uint32_t C)
  {
    _spi_dev->data_buf[0] = C;
    _spi_dev->mosi_dlen.usr_mosi_dbitlen = 7;
    _spi_dev->cmd.usr = 1;
/*
    _spi_dev->ctrl2.miso_delay_mode=0;
    _spi_dev->user.usr_mosi_highpart = 0;
    _spi_dev->user.usr_mosi = 1;
    _spi_dev->miso_dlen.usr_miso_dbitlen = 0;
    _spi_dev->user.usr_miso = 0;
    _spi_dev->cmd.usr = 1;
*/
  }
  inline void tft_Write_16(uint32_t C)
  {
    _spi_dev->data_buf[0] = C;
    _spi_dev->mosi_dlen.usr_mosi_dbitlen = 15;
    _spi_dev->cmd.usr = 1;
/*
    _spi_dev->ctrl2.miso_delay_mode=0;
    _spi_dev->user.usr_mosi_highpart = 0;
    _spi_dev->user.usr_mosi = 1;
    _spi_dev->miso_dlen.usr_miso_dbitlen = 0;
    _spi_dev->user.usr_miso = 0;
*/
  }
  inline void tft_Write_32(uint32_t C)
  {
    _spi_dev->data_buf[0] = C;
    _spi_dev->mosi_dlen.usr_mosi_dbitlen = 31;
    _spi_dev->cmd.usr = 1;
/*
    _spi_dev->ctrl2.miso_delay_mode=0;
    _spi_dev->user.usr_mosi_highpart = 0;
    _spi_dev->user.usr_mosi = 1;
    _spi_dev->miso_dlen.usr_miso_dbitlen = 0;
    _spi_dev->user.usr_miso = 0;
*/
  }

  inline void SPI_WAIT(void) { while (_spi_dev->cmd.usr); }

  template <typename T> inline static uint32_t SPI_32(T H, T L) { return ((H)<<8 | (H)>>8) | (((L)<<8 | (L)>>8)<<16 ); }

public:
  void init(void)
  {
    _spi_dev = spicommon_hw_for_host(_spi_host);
    _caset = _paset = 0xffffffff;
    _width = LCD::TFT_WIDTH;
    _height = LCD::TFT_HEIGHT;
    if (CS_PIN >= 0) gpio_set_direction((gpio_num_t)CS_PIN, GPIO_MODE_OUTPUT);
    if (DC_PIN >= 0) gpio_set_direction((gpio_num_t)DC_PIN, GPIO_MODE_OUTPUT);
/*
    spi_bus_config_t buscfg = {
        .mosi_io_num = (gpio_num_t)GFX_CONFIG->mosi,
        .miso_io_num = (gpio_num_t)GFX_CONFIG->miso,
        .sclk_io_num = (gpio_num_t)GFX_CONFIG->clk,
        .quadwp_io_num = -1,
        .quadhd_io_num = -1,
        .max_transfer_sz = 0xFFFFFF,
        .flags = SPICOMMON_BUSFLAG_MASTER,
        .intr_flags = 0};
    ESP_ERROR_CHECK(spi_bus_initialize(VSPI_HOST, &buscfg, 0));  // channel
    spi_device_interface_config_t devcfg = {
        .command_bits = 0,
        .address_bits = 0,
        .dummy_bits = 0,
        .mode = 0, //SPI mode 0
        .duty_cycle_pos = 0,
        .cs_ena_pretrans = 0,
        .cs_ena_posttrans = 0,
        .clock_speed_hz = FREQ,
        .input_delay_ns = 0,
        .spics_io_num = 0,
        .flags = SPI_DEVICE_NO_DUMMY,
        .queue_size = 6,
        .pre_cb = lcd_spi_pre_transfer_callback,
        .post_cb = lcd_spi_post_transfer_callback};
    ESP_ERROR_CHECK(spi_bus_add_device(VSPI_HOST, &devcfg, &_spi_handle));
*/
    //_spi_dev = spicommon_hw_for_host(VSPI_HOST);
  }

  inline void spi_begin(void) {
    SPI_WAIT();
    //_spi.beginTransaction(SPISettings(FREQ, MSBFIRST, LCD::SPI_MODE));
    TPin<CS_PIN>::lo();

    _spi_dev->ctrl1.val = 0;
    _spi_dev->ctrl2.val = 0;
    _spi_dev->miso_dlen.usr_miso_dbitlen = 0;
    _spi_dev->user.cs_setup=0;
    _spi_dev->user.usr_dummy=0;
    _spi_dev->user.usr_dummy_idle=0;
    _spi_dev->user.usr_miso = 0;
    _spi_dev->user.usr_mosi = 1;
    _spi_dev->user.usr_mosi_highpart = 0;
    _spi_dev->user.usr_prep_hold=0;
  }

  inline void spi_begin_fill(void) {
    SPI_WAIT();
    //if (FREQ_FILL == -1) _spi.beginTransaction(SPISettings(FREQ     , MSBFIRST, LCD::SPI_MODE));
    //else                 _spi.beginTransaction(SPISettings(FREQ_FILL, MSBFIRST, LCD::SPI_MODE));
    TPin<CS_PIN>::lo();

    _spi_dev->ctrl1.val = 0;
    _spi_dev->ctrl2.val = 0;
    _spi_dev->miso_dlen.usr_miso_dbitlen = 0;
    _spi_dev->user.cs_setup=0;
    _spi_dev->user.usr_dummy=0;
    _spi_dev->user.usr_dummy_idle=0;
    _spi_dev->user.usr_miso = 0;
    _spi_dev->user.usr_mosi = 1;
    _spi_dev->user.usr_mosi_highpart = 0;
    _spi_dev->user.usr_prep_hold=0;
  }

  inline void spi_end(void) {
    SPI_WAIT();
    TPin<CS_PIN>::hi();
    //_spi.endTransaction();
  }

  inline uint16_t width(void) const { return _width; }
  inline uint16_t height(void) const { return _height; }
  inline uint8_t getRotation(void) const { return _rotation; }
  inline void setRotation(uint8_t r) {
    r = r & 7;
    _rotation = r;
    if (r & 1) {
      _width  = LCD::TFT_HEIGHT;
      _height = LCD::TFT_WIDTH;
    } else {
      _width  = LCD::TFT_WIDTH;
      _height = LCD::TFT_HEIGHT;
    }
    _colstart = LCD::rotations[r].colstart;
    _rowstart = LCD::rotations[r].rowstart;
    _caset = _paset = 0xffffffff;
    SPI_WAIT(); TPin<DC_PIN>::lo(); tft_Write_8(LCD::TFT_MADCTL);
    SPI_WAIT(); TPin<DC_PIN>::hi(); tft_Write_8(LCD::rotations[r].madctl);
  }

  void writeBlock(uint32_t color, uint32_t repeat)
  {
    uint32_t color32 = LCD::UINT32_COLOR16x2(color);
    SPI_WAIT();
    if (repeat > 31)
    {
      _spi_dev->mosi_dlen.usr_mosi_dbitlen = 511;
      do
      {
        taskDISABLE_INTERRUPTS();
        _spi_dev->data_buf[0] = color32;
        _spi_dev->cmd.usr = 1;
        for (uint32_t i=1; i < 16; i++) _spi_dev->data_buf[i] = color32;
        taskENABLE_INTERRUPTS();
        repeat -= 32;
        if (repeat) SPI_WAIT();
      } while (repeat > 31);
    }
    if (repeat)
    {
      taskDISABLE_INTERRUPTS();
      _spi_dev->data_buf[0] = color32;
      _spi_dev->mosi_dlen.usr_mosi_dbitlen = (repeat << 4) - 1;
      _spi_dev->cmd.usr = 1;
      for (uint32_t i=1; i <= (repeat>>1); i++) _spi_dev->data_buf[i] = color32;
      taskENABLE_INTERRUPTS();
    }
  }

  void writePixel(uint32_t color)
  {
    SPI_WAIT(); tft_Write_16(LCD::UINT32_COLOR16(color));
  }

  void setWindow(int32_t xs, int32_t ys, int32_t xe, int32_t ye, bool force = false)
  {
    // Col addr set
    if (_colstart) { xs += _colstart; xe += _colstart; }
    uint32_t caset = SPI_32(xs, xe);
    if (_caset != caset || force)
    {
      SPI_WAIT(); taskDISABLE_INTERRUPTS(); tft_Write_8(LCD::TFT_CASET); TPin<DC_PIN>::lo(); taskENABLE_INTERRUPTS();
      SPI_WAIT(); taskDISABLE_INTERRUPTS(); tft_Write_32(caset);         TPin<DC_PIN>::hi(); taskENABLE_INTERRUPTS();
      _caset = caset;
    }

    // Row addr set
    if (_rowstart) { ys += _rowstart; ye += _rowstart; }
    uint32_t paset = SPI_32(ys, ye);
    if (_paset != paset || force)
    {
      SPI_WAIT(); taskDISABLE_INTERRUPTS(); tft_Write_8(LCD::TFT_PASET); TPin<DC_PIN>::lo(); taskENABLE_INTERRUPTS();
      SPI_WAIT(); taskDISABLE_INTERRUPTS(); tft_Write_32(paset);         TPin<DC_PIN>::hi(); taskENABLE_INTERRUPTS();
      _paset = paset;
    }
    // write to RAM
    SPI_WAIT(); taskDISABLE_INTERRUPTS(); tft_Write_8(LCD::TFT_RAMWR); TPin<DC_PIN>::lo(); taskENABLE_INTERRUPTS();
    SPI_WAIT();                                                        TPin<DC_PIN>::hi();
  }
  void drawPixel(int32_t x, int32_t y, uint32_t color)
  {
    // Col addr set
    if (_colstart)  x += _colstart;
    uint32_t caset = (x << 24) | (x << 8) | (x >> 8);
    if (_caset != caset)
    {
      SPI_WAIT(); taskDISABLE_INTERRUPTS(); tft_Write_8(LCD::TFT_CASET); TPin<DC_PIN>::lo(); taskENABLE_INTERRUPTS();
      SPI_WAIT(); taskDISABLE_INTERRUPTS(); tft_Write_32(caset);         TPin<DC_PIN>::hi(); taskENABLE_INTERRUPTS();
      _caset = caset;
    }

    // Row addr set
    if (_rowstart)  y += _rowstart;
    uint32_t paset = (y << 24) | (y << 8) | (y >> 8);
    if (_paset != paset)
    {
      SPI_WAIT(); taskDISABLE_INTERRUPTS(); tft_Write_8(LCD::TFT_PASET); TPin<DC_PIN>::lo(); taskENABLE_INTERRUPTS();
      SPI_WAIT(); taskDISABLE_INTERRUPTS(); tft_Write_32(paset);         TPin<DC_PIN>::hi(); taskENABLE_INTERRUPTS();
      _paset = paset;
    }

    // write to RAM
    SPI_WAIT(); taskDISABLE_INTERRUPTS(); tft_Write_8(LCD::TFT_RAMWR);              TPin<DC_PIN>::lo(); taskENABLE_INTERRUPTS();
    SPI_WAIT(); taskDISABLE_INTERRUPTS(); tft_Write_16(LCD::UINT32_COLOR16(color)); TPin<DC_PIN>::hi(); taskENABLE_INTERRUPTS();
  }
};

#endif
